"""
skill_interpreter.py

This module interprets a VA Java method and generates a natural-language
description of the user-intent behind that method. The output schema includes:

    {
      "<methodName>": {
        "description-short": "<short natural language intent>",
        "description-detail": "<detailed natural language intent>"
      }
    }

The interpreter uses two prompts:

- PROMPT_DIRECT_INTENT_SHORT: produce a <=5-word short intent summary
- PROMPT_DIRECT_INTENT_DETAIL: produce a <=20-word detailed description

Additionally, it can incorporate app-level context from:
    workspace/<app_id>/input/app_introduction.txt

This file is intended to work with VA Java methods generated by AVA-Gen.
"""

from __future__ import annotations

import json
import os
import re
from typing import List, Dict, Optional

from core.api.openai_client import send_request_to_gpt
from .models import SkillSchema
from .prompts import (
    PROMPT_EXTRACT_PARAMETERS,
    PROMPT_DIRECT_INTENT_DETAIL,
    PROMPT_DIRECT_INTENT_SHORT,
)


# ================================================================
# Utility helpers
# ================================================================

def extract_method_name_from_java(java_code: str) -> str:
    """
    Extract the VA method name from its Java signature.

    Example:
        public void createNewEntry() { ... }
                     ^^^^^^^^^^^^^^

    The extracted name will be used as the skill name key in the final JSON.
    """
    match = re.search(r"public\s+void\s+(\w+)\s*\(", java_code)
    return match.group(1) if match else "UnknownIntent"


def clean_text(s: str) -> str:
    """
    Light cleanup of GPT outputs by:
      - removing extra whitespace
      - collapsing newlines
      - normalizing spaces
      - normalizing quotes/backticks to plain ASCII
      - escaping single quotes for safe storage
    """
    cleaned = s.strip().replace("\n", " ").replace("  ", " ").strip()
    quote_map = {
        "’": "'",
        "‘": "'",
        "`": "'",
        "“": '"',
        "”": '"',
    }
    for src, tgt in quote_map.items():
        cleaned = cleaned.replace(src, tgt)
    # Escape single quotes to avoid issues with some storage backends
    cleaned = cleaned.replace("'", "\\'")
    return cleaned


def load_app_introduction(
    workspace_root: str,
    app_id: Optional[str],
) -> str:
    """
    Load app introduction text from:

        workspace/<app_id>/input/app_introduction.txt

    If app_id is None or the file does not exist, return an empty string.
    """
    if not app_id:
        return ""

    intro_path = os.path.join(
        workspace_root,
        app_id,
        "input",
        "app_introduction.txt",
    )

    if not os.path.isfile(intro_path):
        return ""

    with open(intro_path, "r", encoding="utf-8") as f:
        return f.read().strip()


# ================================================================
# GPT-backed helper functions
# ================================================================

def collect_parameters(va_code: str) -> List[str]:
    """
    Ask GPT to list the parameter names of the VA method.

    This logic is preserved for compatibility with earlier versions,
    but the results are NOT used in the final schema.
    """
    prompt = PROMPT_EXTRACT_PARAMETERS.format(code=va_code)
    response = send_request_to_gpt(prompt, structured_output=True)
    data = json.loads(response)
    return data.get("parameters", [])


def generate_detailed_intent(va_code: str, app_intro: str) -> str:
    """
    Produce a ≤20-word description of the method's user intent,
    using PROMPT_DIRECT_INTENT_DETAIL and app-level introduction.
    """
    prompt = PROMPT_DIRECT_INTENT_DETAIL.format(
        code=va_code,
        app_intro=app_intro or "(No app introduction provided.)",
    )
    return clean_text(send_request_to_gpt(prompt))


def generate_short_intent(va_code: str, app_intro: str) -> str:
    """
    Produce a ≤5-word short intent label,
    using PROMPT_DIRECT_INTENT_SHORT and app-level introduction.
    """
    prompt = PROMPT_DIRECT_INTENT_SHORT.format(
        code=va_code,
        app_intro=app_intro or "(No app introduction provided.)",
    )
    return clean_text(send_request_to_gpt(prompt))


# ================================================================
# MAIN INTERPRETER ENTRY
# ================================================================

def interpret_per_method(
    va_code: str,
    *,
    workspace_root: str = "workspace",
    app_id: Optional[str] = None,
) -> Dict[str, dict]:
    """
    Interpret a VA Java method and generate a concise skill schema.

    Output format:
        {
          "<methodName>": {
            "description-short": "<short natural-language description>",
            "description-detail": "<detailed natural-language description>"
          }
        }

    Parameters
    ----------
    va_code : str
        The full VA Java method source code.
    workspace_root : str
        Root path of the AVA-Gen workspace (default: "workspace").
    app_id : Optional[str]
        If provided, we will try to load:
            {workspace_root}/{app_id}/input/app_introduction.txt
        and pass that text into the GPT prompts as context.

    Steps:
      1. Extract method name (skill name).
      2. Load app introduction (if app_id is given).
      3. Ask GPT for short & detailed intent descriptions with that context.
      4. Construct SkillSchema dataclass.
      5. Return output as dictionary.
    """
    # 1) Extract skill name from Java signature
    method_name = extract_method_name_from_java(va_code)

    # 2) Load app-level introduction (optional)
    app_intro = load_app_introduction(workspace_root, app_id)

    # 3) Generate descriptions with app context
    description_detail = generate_detailed_intent(va_code, app_intro)
    description_short = generate_short_intent(va_code, app_intro)

    # 4) Build schema object (two fields only)
    schema = SkillSchema(
        description_short=description_short,
        description_detail=description_detail,
    )

    # 5) Final output structure
    return {method_name: schema.to_dict()}


def interpret_all_methods(
    app_id: str,
    *,
    workspace_root: str = "workspace",
) -> None:
    """
    Read all VA methods (.java) under:
        {workspace_root}/{app_id}/va_methods/

    For each VA method:
      - Read file content
      - Call interpret(...) to get a per-method JSON object:
            { "<methodName>": { ... } }
      - Merge them under "context_methods"

    Finally, write the merged result into:
        {workspace_root}/skills_description/{app_id}_skills_description.json

    No return value (writes to disk).
    """

    # -------------------------------
    # Directory setup
    # -------------------------------
    app_root = os.path.join(workspace_root, app_id)
    va_dir = os.path.join(app_root, "va_methods")
    output_dir = os.path.join(workspace_root, "skills_description")

    if not os.path.isdir(va_dir):
        raise FileNotFoundError(f"VA methods directory not found: {va_dir}")

    os.makedirs(output_dir, exist_ok=True)

    # -------------------------------
    # Accumulate results
    # -------------------------------
    context_methods: Dict[str, dict] = {}

    for fname in os.listdir(va_dir):
        if not fname.endswith(".java"):
            continue

        va_path = os.path.join(va_dir, fname)
        if not os.path.isfile(va_path):
            continue

        with open(va_path, "r", encoding="utf-8") as f:
            va_code = f.read()

        # Per-method interpretation
        single_result = interpret_per_method(
            va_code,
            workspace_root=workspace_root,
            app_id=app_id,
        )

        for method_name, description_obj in single_result.items():
            context_methods[method_name] = description_obj

    # -------------------------------
    # Final JSON structure
    # -------------------------------
    output_json = {
        "app_id": app_id,
        "context_methods": context_methods
    }

    # Output file path
    output_path = os.path.join(output_dir, f"{app_id}_skills_description.json")

    # Write result
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(output_json, f, indent=4, ensure_ascii=False)

    print(f"[AVA-Gen] Skill description written to: {output_path}")


if __name__ == "__main__":
    # Example: interpret all VA methods for existing workspace app
    interpret_all_methods(app_id="hu.vmiklos.plees_tracker", workspace_root="workspace")
